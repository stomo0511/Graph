- Python で networkx モジュールを使ってグラフの操作をするプログラムを作っている。

- 無向グラフHとキンググラフGの２つがある。

- Hのノード数をnとして、Gは (n-1)xn のノードを持つ。

- グラフHの初期化コードは以下の通り。

H = nx.Graph()
H.add_nodes_from([0, 1, 2, 3, 4])
H.add_edges_from([(0, 1), (0, 2), (0, 4), (1, 2), (2, 3), (2, 4), (3, 4)])
n = H.number_of_nodes()   # グラフHのノード数
H_nodes = list(H.nodes()) # グラフHのノードリスト

- グラフGのノードにはグラフHのノード番号に対応する属性 val が追加されている。グラフGの初期化コードは以下の通り。

G = nx.grid_2d_graph(n-1, n)

# 斜め方向のエッジを追加
for x, y in G.nodes():
    if (x+1, y+1) in G.nodes():
        G.add_edge((x, y), (x+1, y+1))
    if (x+1, y-1) in G.nodes():
        G.add_edge((x, y), (x+1, y-1))

for x, y in G.nodes():
    if x == 0:  # 第0行の場合
        G.nodes[(x, y)]['val'] = H_nodes[y]
    else:
        # x + y が偶数の場合
        if (x + y) % 2 == 0:
            G.nodes[(x, y)]['val'] = G.nodes[(x - 1, max(0, y - 1))]['val']
        # x + y が奇数の場合
        else:
            G.nodes[(x, y)]['val'] = G.nodes[(x - 1, min(n - 1, y + 1))]['val']

- このプログラムのための関数 mVG を定義したい。mVG は頂点集合 nodes 内の任意に頂点vに関して、グラフG'上で v の頂点集合と隣接する連結グラフの頂点を返す。一意に定まらない場合は頂点数がなるべく少ない連結グラフを求める。

- 関数 mVG は以下の２つの条件を満たす頂点集合を返す。ここで \phi(v)は
1. \phi(v) に含まれる全頂点と、G'のすべての辺を用いて1つの連結グラフが構成可能である
2. 頂点集合 nodes 内の任意の頂点 v に関して、グラフ G' 上で \phi(v) と隣接する

- 関数 mVG は幅優先探索による頂点探索とバックトラックのメモ化を用いている。

- メインプログラムの擬似コードを以下に示す。以下で入力グラフGは、初期化後のグラフGとする。出力はグラフHが埋め込まれたグラフG。以下で \phi(v) はグラフGのval=vであるような頂点からなるGのサブグラフとする。また、neighbor(vj)はグラフHにおけるvjの隣接頂点を表す。したがって、vi=0, vj=1について neighbor(vj) \ vi = {2} となる。mVGの２回目の呼び出しにおける (G, ' ') は、グラフGの頂点のうちval=' 'であるような頂点からなるGのサブグラフとする。

Input: graph H with vertices { v1, ..., vn },  King graph G
Output: King G

while stopping criterion is not met do
  for vi \in { v1, ..., vn } do
    \phi(vi) <- {}
    for vj \in neighbor(vi) do
      \phi(vj) <- mVG( \phi(vj), neighbor(vj) \ vi)
    endfor
    \phi(vi) <- mVG( (G, ' '), neighbor(vi))
  endfor
end while

- グラフGのノードの val 値を変更する関数を以下で定義した。

def set_node_val(G, node, new_val):
    if node in G.nodes():
        G.nodes[node]['val'] = new_val
#        print(f"Node {node} val updated to {new_val}")
    else:
        print(f"Node {node} not found in graph G")

- グラフGで同一の val 値を持つノードを返す関数を以下で定義した。

def get_nodes_with_val(G, val):
    return [node for node, data in G.nodes(data=True) if data.get('val') == val]

- ここから実例
- 関数 mVG を実装しなさい。