- Python で networkx モジュールを使ってグラフの操作をするプログラムを作っている。
- 無向グラフHとキンググラフGの２つがある。
- Hのノード数をnとして、Gは (n-1)xn のノードを持つ。
- グラフHの初期化コードは以下の通り。
H = nx.Graph()
H.add_nodes_from([0, 1, 2, 3, 4])
H.add_edges_from([(0, 1), (0, 2), (0, 4), (1, 2), (2, 3), (2, 4), (3, 4)])
n = H.number_of_nodes()   # グラフHのノード数
H_nodes = list(H.nodes()) # グラフHのノードリスト

- グラフGのノードにはグラフHのノード番号に対応する属性 val が追加されている。グラフGの初期化コードは以下の通り。

G = nx.grid_2d_graph(n-1, n)

for x, y in G.nodes():
    if x == 0:  # 第0行の場合
        G.nodes[(x, y)]['val'] = H_nodes[y]
    else:
        # x + y が偶数の場合
        if (x + y) % 2 == 0:
            G.nodes[(x, y)]['val'] = G.nodes[(x - 1, max(0, y - 1))]['val']
        # x + y が奇数の場合
        else:
            G.nodes[(x, y)]['val'] = G.nodes[(x - 1, min(n - 1, y + 1))]['val']

- 作成するプログラムの目的は、グラフGの同一のval値を持つ頂点をできる限り少なくすること。ただし、グラフGで同一のval値を持つ頂点の集合とグラフHの対応する頂点は同一の接続関係を持つ。

- このプログラムのための関数 mVG を定義したい。mVG は頂点集合 nodes 内の任意に頂点vに関して、グラフG'上で v の頂点集合と隣接する連結グラフの頂点を返す。一意に定まらない場合は頂点数がなるべく少ない連結グラフを求める。

- 関数 mVG は以下の２つの条件を満たす頂点集合を返す。ここで \phi(v)は
1. \phi(v) に含まれる全頂点と、G'のすべての辺を用いて1つの連結グラフが構成可能である
2. 頂点集合 nodes 内の任意の頂点 v に関して、グラフ G' 上で \phi(v) と隣接する

- 関数 mVG は幅優先探索による頂点探索とバックトラックのメモ化を用いている。

- mVGの擬似コードは以下の通り。

Input: Graph: G, node: vj, node list: nodes
Output: node list \xi of G

G' is a subgraph of G such that the val value of its nodes is vj
for d=1,2,... do
  for v \in nodes do
    set distance d to verteces whose distance from \phi(v) equales to d
  endfor
  if a vertex in G' has distance from \phi(v) for all v \in nodes
  then
    the vertex is called v* and break from this loop
  endif
endfor
\xi <- { v* }
for v \in nodes do
  \xi <- \xi \bigcup verteces in the shortest path from a vertex in \xi to a vertex in \phi(v)
endfor
return \xi



- メインプログラムの擬似コードを以下に示す。以下で入力グラフGは、初期化後のグラフGとする。

Input: graph H with vertices { v1, ..., vn },  graph G
Output: vertex-models \phi(v1), ..., \phi(vn) of an H-minor in G

while stopping criterion is not met do
  for vi \in { v1, ..., vn } do
    \phi(vi) <- {}
    for vj \in neighbor(vi) do
      \phi(vj) <- mVG( G, vj, neighbor(vj) \ vi)
    endfor
      \phi(vi) <- mVG( G, ' ', neighbor(vi))
  endfor
end while

- グラフGのノードの val 値を変更する関数を以下で定義
def set_node_val(G, node, new_val):
    if node in G.nodes():
        G.nodes[node]['val'] = new_val
#        print(f"Node {node} val updated to {new_val}")
    else:
        print(f"Node {node} not found in graph G")

- グラフGで同一の val 値を持つノードを返す関数を以下で定義
def get_nodes_with_val(G, val):
    return [node for node, data in G.nodes(data=True) if data.get('val') == val]

- vi=0, グラフGを初期化した後、以下で val=vi のノードの val値をリセットした。
for node in get_nodes_with_val(G, H_nodes[vi]):
    set_node_val(G, node, '')

このあと、vj=1, mVG(\phi(vj), neighbor(vj) \ vi) は [(0,1)] を返し、(1,0), (2,0), (3,1) の val値は '' となる。グラフGの頂点のval値を set_node_val(G, (0,1), vj), set_node_val(G, (1,0), ''), set_node_val(G, (2,0), ''), set_node_val(G, (3,1), '') で更新する。
さらに、vj=2, mVG(\phi(vj), neighbor(vj) \ vi) は　[(0,2), (1,3)] を返し、(2,4), (3,4) のval値は '' となる。グラフGの頂点のval値を set_node_val(G, (0,2), vj), set_node_val(G, (1,3), vj), set_node_val(G, (2,4), ''), set_node_val(G, (3,4), '') で更新する。
さらに、vj=4, mVG(\phi(vj), neighbor(vj) \ vi) は ([0,4]) を返し、(1,4), (2,3), (3,2) のval値は '' となる。グラフGの頂点のval値を set_node_val(G, (0,4), vj),  set_node_val(G, (1,4), ''), set_node_val(G, (2,3), ''), set_node_val(G, (3,2), '') で更新する。

- 関数 mVG を実装しなさい。